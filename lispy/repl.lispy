(def bar 1)

(defn test[x] (+ 1 2))

(defn foo[x] (+ 1 2))
(defn bar[x] (+ 1 2))
;; (defn foo [x] (+ 1 x))
;; (defn fox [x] (fn [] x))
;; (defn foz [x] (let [a (+ x 1)
;;                     a (+ a 1)
;;                     b 123]
;;                 (fn [x y] (+ a b x y bar))))

;; (fn [x y a b] (+ a b x y bar))

;; {:wasm-fn-ref 1
;;  :parameter-count 2
;;  :parameters-list (42)
;;  :closure-list (5 7)
;;  }



;; ((foz 1) 1)


;; (def foo 123)
;; (def fox "abc")
;; (print-env)
;; (let [a foo]
;;   (def fuz a))
;; (def fux (let [a 1] a))
;; (defn bar [x] (let [f (fn [] (+ foo x))]
;;                f))

;; (defmacro m0 [x y] `(+ ~x ~y))
;; (defmacro m1 [x y] `(+ ~x ~y (m0 6 7)))
;; (def m2 (macro [y] `(m1 (m1 2 3) ~y)))
;; ;; (defmacro m2 [y] `(+ 123 ~y))
;; (print foo)
;; ((bar 123))

;; (macroexpand-all '(m2 123))

;; (defn me [form]
;;   (macroexpand form)
;;   )

;; (me '(m2 123))
;; (print "foo")


;; (macroexpand-all '(m2 1))
;; (and (+ 1 2) (= 1 2) (print "FOOOOO"))
;; (macroexpand (list 1 2))

;; (and false (print "foo"))


;; (macroexpand-all '(a b c))
;; (and (= 1 0) true)

;; (macroexpand '(apply + '(1 2)))
;; (apply and '(1 2))
;; (cons (first '(a b c))  (rest '(a b c)))
;; (+ 1 2)
;; (slurp "lispy/stdlib.lispy")
;; (slurp "lispy/test/test_2_eval.lispy")
;; (slurp "lispy/test/test_3_env.lispy")
;; (slurp "lispy/test/test_4_if_fn_do.lispy")
;; (slurp "lispy/test/test_5_tco.lispy")
;; (slurp "lispy/test/test_6_file.lispy")
;; (slurp "lispy/test/test_7_quote.lispy")
;; (slurp "lispy/test/test_8_macros.lispy")
;; (slurp "lispy/test/test_9_try.lispy")

;; ;; (print "Hello!!" (+ 2 2))
;; (print "Hash" (hash "foo"))
;; (print "Hash" (hash "foo"))

;; (print (boolean 123))
;; (print (hash 2))
;; (list 1 2)
;; (print (hash (cons 1 (list 2 3))))
;; (print (hash (cons 1 (list 2 (+ 2 1)))))
;; (print (hash (cons 1 '(2 3))))
;; (print (hash (rest (cons 1 (list 2 3)))))
;; "ok"
;; foobar
;; (t ( (fn [& more] (count more)) 1 2 3)
;;    3)
;; (t ( (fn [& more] (list? more)) 1 2 3)
;;    true)
;; "ok"
;; foo?
;; foo?
;; (t ( (fn [& more] (count more)) 1)
;;    1)
;; (t ( (fn [& more] (count more)) )
;;    0)
;; ;; (t ( (fn [& more] (list? more)) )
;; ;;    true)
;; (t ( (fn [a & more] (count more)) 1 2 3)
;;    2)
;; (t ( (fn [a & more] (count more)) 1)
;;    0)
;; (t ( (fn [a & more] (list? more)) 1)
;;    true)
;; (t (not nil)
;;    true)
;; (t (not true)
;;    false)
;; (t (not "a")
;;    false)
;; (t (not 0)
;;    false)

;; (t (= "" "")
;;    true)
;; (nth [1 2] 123)
;; (cond)
;; (not (not 1))
;; (defmacro unless2 [pred a b] (list 'if (list 'not pred) a b))
;; (print "hello")
;; (macroexpand '(cond 1 2))
;; (cond 0 1 1 2 1 3kkk)
;; (nth [1 2 3] 1)
;; (cond 1 7)
;; (slurp "lispy/test/test_9_try.lispy")
;; (t 1 0)
;; (+ 1 1)
;; (+ 1 1)
;; (+ 1 a)
;; (+ 1 123)
;; foo
;; ((fn [a b] (+ b a)) 3 4)

;; ((fn [f x] (f x))
;;  (fn [a] (+ 1 a))
;;  7)
;; ( ( (fn [a] (fn [b] (+ a b))) 5) 7)

;; (def x 4)
;; (defmacro a [] x)
;; (a)
;; ;=>2
;; (let [x 3]
;;   (print x)
;;   (a))
;; (let [foo (fn [n] (if (= n 1) (foo 0)))] (print-env) (foo 1))
;; (let [cst (fn [n] (if (= n 0) 0 (cst (- n 1))))] (cst 1))

;; (def fib (fn [N] (if (= N 0) 1 (if (= N 1) 1 (+ (fib (- N 1)) (fib (- N 2)))))))
;; =>2
;; (if nil 7 8)
;; 8
;; (if (list) 7 8) 7

;; (t (a 1 2 3) 2)
;; (def expr '(abc 1 2 3))
;; (when (not= (eval expr) 2)
;;   (do (pr expr))
;;   )

;; (+ 1 (+ 1 1))
;; (+ (+ 5 (* 2 3)) 3)
;; (defn x [y] y)
;; (x 1)

;; (pr '(+ 1 2))
;; (t (+ 1 2) 3)
;; (print "hello")
;; (defmacro when [cond body]
;;   `(if ~cond ~body))

;; (def t (macro [] (do 1 2 3)))
;; (def t (macro [] (do 1)))

;; (macroexpand '(t))
;; (defmacro when [cond body]
;;   `(if ~cond ~body))

;; (macroexpand '(t ))
;; (macroexpand '(when 1 2))
;; (when 1 2)
;; (load "lispy/test/test_2_eval.lispy")

;; 1
;; (+ 1)
;; [ 1 ]
;; '(1 2 3)
;; (cons 0 '(1 2 3))
;; (first '(1 2 3))
;; (rest  '(1 2 3))
;; (list 1 2 3)
;; (concat '(1 2) '(3 4))
;; (concat '(1 2) '())
;; (concat '() '(3 4))
;; (def a "FOOOOOOOOOOOOOOOOOOo")
;; (def a "UUUUUUUUUUUUUUUUU")
;; (pr a)
;; (if 1 2 3)
;; (fn [a b c] a)

;; (def a "baaaaaaaaaaaaaaar")
;; (+ 1 1)
;; `(a ~@(list a))


;; (try
;;  123
;;   (throw "foo")
;;   (catch E e e)
;;   (finally (pr ":finally")))

;; (let [a "THIS IS A!!!!!!"
;;       b 1
;;       c [1 2 3]
;;       ]
;;  'a
;;   456
;;   (let [d c]
;;    'b 'c
;;     (let [e d]
;;      'd
;;       b))
;;  123
;;   )

;; (let [] 123 'd 3)


;; (def f (fn [a] a))
;; (f 123)

;; (def defmacro (macro [sym params & body]
;;                      `(def ~sym (macro ~params ~@body))))

;; (macroexpand '(defmacro ))

;; (defmacro defn [sym params & body])

  ;; `(def ~sym (fn ~params ~@body)))

  ;; `(def ~sym (fn ~params ~@body))

;; (def defn (macro [sym params & body] `(def ~sym (fn ~params ~@body))))

;; (defn x [y] y)
;; (macroexpand '(defmacro x [y] y))
;; (macroexpand '(defn x [y] y))
;; (x 123)
;; (print-env)
;; (defn x [x y z]
;;   (let [ret (+ x y z)]
;;     ret))

;; (def foo (x 1 2 ))
;; 3

;; (def foo (macro [sym params & body] `(def ~sym (macro ~params ~@body))))
;; (def foo (fn [& args] args))
;; (foo 1 2 3)
;; (foo x [y] 'b1 'b2)
;; (print "&&&&&&&&&&&&&&&&" (macroexpand '(foo x [x y]  1 2)))
;; (foo x [x y]  1 2)
;; (print-env)
;; (def x (macro [x y] 1 2))
;; (x 3 4)
;; x
;; (print foo)
;; foo
;; 234
;; (defmacro foo [x] `(print ~x))
;; (foo x)
;; x
;; (def sym 1)
;; (def params [1 2])
;; (def body  [1 2 3])
;; `(~@body)
;; `(~@(list 1))


;; (def foo (macro [x] (list 'pr x)))
;; (def foo (macro [x] x))
;; (def bar (macro [y] (print 123) (list 'foo y)))

;; (foo "WITHOUT QUOTES?" )
;; (bar "WITHOUT QUOTES?" )
;; (macroexpand '(foo 123))
;; 1

