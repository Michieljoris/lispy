(def defmacro (macro [sym params & body]
                     `(def ~sym (macro ~params ~@body))))

(defmacro defn [sym params & body]
  `(def ~sym (fn ~params ~@body)))

(defmacro cond [& xs]
  (if (> (count xs) 0)
    (list 'if (first xs)
          (if (> (count xs) 1)
            (nth xs 1)
            (throw "odd number of forms to cond"))
          (cons 'cond (rest (rest xs))))))

(defn debug-on []
  (debug 1))

(defn debug-off []
  (debug 0))

(defmacro when [cond body]
  `(if ~cond ~body))

(defmacro not [b]
  `(if ~b false true))

(defmacro t [expr expected & str]
  (when (not=  (eval expr) expected)
    (do
      (pr "FAIL:" (first str))
      (pr expr)
      (pr "Expected:" expected)
      (pr "Got::" (eval expr)))))


(defmacro apply [f args]
  `(eval (cons ~f ~args)))

(defn and* [args]
  (if (= (count args) 1)
    (first args)
    (if (= (count args) 0)
      true
      (if (not (eval (first args)))
        (first args)
        (apply and (rest args))))))

(defmacro and [& args]
  (and* args))

(defmacro macroexpand-all [form]
  (list 'let ['form `(macroexpand ~form)]
        '(if (list? form)
           (if (> (count form) 0)
             (cons (macroexpand-all (first form)) (macroexpand-all (rest form)))
             form)
           form)))


;; (defn [test cond]
;;   {if (eval cond)
;;    {print cond}

;;    })


;; (defn {unpack f xs}
;;   {eval (join (list f) xs)})

;; (defn {pack f & xs}
;;   {f xs})

;; (def {uncurry} pack)

;; (def {curry} unpack)

;; (def {apply} unpack)

;; (defn {len l}
;;   {if (= l {})
;;    {0}
;;    {+ 1 (len (tail l))}})

;; (defn {reverse l} {
;;   if (= l {})
;;     {{}}
;;     {join (reverse (tail l)) (head l)}
;; })

;; (defn {when cond body}
;;   {if cond
;;    {eval body}
;;    {}})

;; (defn {test cond}
;;   {if (eval cond)
;;    {}
;;    {print cond}})

;; ;; (print "stdlib loaded")


;; (def defn
;;   (fn [args body]
;;    (def (first args)
;;     (fn (rest args) body))))

;; (defmacro defun [s params & body]
;;   `(def ~s (fn ~params ~@body)))
