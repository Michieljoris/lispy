#+TITLE: Todo
* Implement as much as possible in lispy itself
Then there's less work for the compiler.
* TODO
** use lists for env and for sexpr nodes
- Can't use nodes for collections since the node field needs reallocing. Can't do that with fixed pool memory
So we must use lists for those. Perhaps we can use hamt and pvector if we need maps and vectors.
- We want lispy lists persistent.
- If we don't copy lvals from env they'll have to be immutable.
- when env is created it should be a snapshot. Any modifications to it shouldn't affect any closures already bound.
  ->> so they have to be immutable as well.
  WELL... : this goes for let, not for def!!!!!
-
- ? Should env be a palist? Instead of just an alist? So persistent? Well, persistent, see last point
    in other words, when setting values in the env do we overwrite if existing? Or treat the env as persistent.
- ? When do we throw environments away?
  We throw closures, not envs away when the fn that uses is goes out of scope!!!
  When does env get created?
  -> on let (the local bindings)
  -> when evaluating lambda (the param bindings)
  -> in catch
- >>>>>>> So all should be persistent (or copied over) and big Q remains: when do we release lvals???

** replace mpc
** put ifdefs in for system libs
#include <stdarg.h>  //va_start, va_list
#include <stdio.h>   //printf, puts
#include <stdlib.h>  //malloc, calloc, realloc
** reference counting
*** TCO -> work out freeing tco_env for it!!!!!!
- eval_lambda_call
- let
- do
** add rest of tests from mal
** More
*** maps
*** stdlib
**** map, reduce, apply, when, unpack (apply, curry), pack (uncurry)

*** keywords
*** special forms
**** DONE do special form
**** DONE let special form
**** loop, recur
*** hamt for symbol lookup and lispy maps
*** pvector
*** namespaces
*** call/cc
** compile to wasm using emscrypten
and link them to compiled lispy code
runtime includes:
- env mechanism
- builtin fns
- interpreter for eval??
- certainly for any inbuilt repl

* Ch10
 Add a builtin function cons that takes a value and a Q-Expression and appends it to the front.
 Add a builtin function len that returns the number of elements in a Q-Expression.
 Add a builtin function init that returns all of a Q-Expression except the final element.
* Ch12
Define a builtin_fun C function that is equivalent to the Lisp fun function.
* Ch13
Create builtin logical operators or ||, and && and not ! and add them to the language.
Define a recursive Lisp function that returns the nth item of that list.
Define a recursive Lisp function that returns 1 if an element is a member of a list, otherwise 0.
Define a Lisp function that returns the last element of a list.
Define in Lisp logical operator functions such as or, and and not.
Add a specific boolean type to the language with the builtin variables true and false
* Ch14
Adapt the builtin function join to work on strings.
Adapt the builtin function head to work on strings.
Adapt the builtin function tail to work on strings.
Create a builtin function read that reads in and converts a string to a Q-expression.
Create a builtin function show that can print the contents of strings as it is (unescaped).
Create a special value ok to return instead of empty expressions ().
Add functions to wrap all of C's file handling functions such as fopen and fgets.


* done
** DONE closures
** DONE returning partials from fn not working
** DONE memory pool
** DONE persistend list with mem pool
