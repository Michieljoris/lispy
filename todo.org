* TODO compiler
** wasmify_lval, finish compile_quote
** quote
** compile the beginning of a test suite
** partial
** ----------------
** add release and retain to wasm code
*** releasing a lval_wasm_lambda!!!
we need to free its closure and partials!!
*** deciding whether a compiled macro was a fn call!!
*** releasing args to sys fn!!!

** apply
https://github.com/clojure/clojure/blob/38bafca9e76cd6625d8dce5fb6d16b87845c8b9d/src/clj/clojure/core.clj#L660
Use core lib fn to reduce args to a single list
Then call wasm implementation of apply* that receives a list and puts them on wajure operand stack and calls fn
** multi arity fns!!!
** loop/recur
** namespaces
** multimethods
** try/throw/catch
** implement: str, quasiquote, doseq, keywords, map, reduce, and, or, xor, doseq, destructering, meta data
** DONE Refactor: return not just Ber, but a struct with info on the compile just done *plus* ber
- so we can more easily see if we just compiled a fn call. iso relying on is_fn_call flag
- we might be able to do optimisations, such as mutually cancelling retain and release calls
** ----------------------------
** don't reuse Ber's!!!
As per warning in Binaryen docs. When reusing optimisations might screw things up.
** better compile time arg count checking
You could be a bit smarter about it at compile time.
1. When a symbol resolves to a sys fn you can check arg count
2. When a symbol resolves to a root lambda fn (as found in compiler env) you can check arg count
3. When a symbol resolves to lval_compiler in some cases we can know whether the
   lval_compiler is a ref to a lambda, and which one eg:
   (let [f (fn [x] x)] (f 123)) but also in:
    (let [f (fn [x y] ..) g (partial f 1)] (g 2)) but not in:
    (fn [g] (g 123))
** (let [a 1] (def f [] a)), so use in non root form
This shouldn't be too hard. We just need to pass a closure to the f lambda
** pass floats, strings, maps, vectors, sets etc from js to wajure fn
Currently only ints work
** named fns for recursion of locally defined lambdas
Also, clojure allows it.
** add and implement maps and sets and vectors with permanent data structures
 hamt
** implement lazy seqs
** max str size, elide with warning or abort
** check for max closure size (currently 128 vars (CHAR512 mempool type))
** find out about and add binaryen optimisations
** add wajure interpreter to the runtime
** add stdlib (defined in wajure and compiled) to runtime
Similar to clojure.core. Probably needs namespaces implemented first
* TODO interpreter
** reader has bug where last parens gets ignored
** add rest of tests from mal
** implement: str, loop/recur, doseq, keywords, apply, map, reduce, and, or, xor, doseq, multimethods, destructering, namespaces, meta data
** implement maps and sets
** replace list implementations of maps, sets and vectors with permanent data structures other than list
-> vector and map hamt.
** implement partial, apply,
** named fns for recursion of locally defined lambdas
Also, clojure allows it.
** multi-arity fns
* TODO Both interpreter and compiler:
** error handling and tracking of line number and pos
Don't cut off compiling, try to continue, produce list of errors.
** gensym and #foo in macro
http://clojure-doc.org/articles/language/macros.html
** implement reader macro for #(+ %1 %2)
** Two special variables are available inside defmacro for more advanced usages:

    &form - the actual form (as data) that is being invoked

    &env - a map of local bindings at the point of macro expansion. The env map is from symbols to objects holding compiler information about that binding.


** implement/copy from clojure.core various macros:
*** Branching:
and or when when-not when-let when-first if-not if-let cond condp cond-> cond->>
*** Looping (see also Sequences):
for doseq dotimes while
*** Working with vars (see also Vars and Environment):
ns declare defmethod defmulti defn- defonce
*** Arranging code differently:
.. doto -> ->>
*** Documenting code:
assert comment doc

* done compiler
** DONE make sure that every fn added has unique wasm name
So wasmified sys fns are called eg sys_print

And lambdas (such as foobar) found in compile env should be renamed and
numbered, eg: l1_foobar, no I don't think that's needed: we use the latest lval
defined for a symbol in the compiler env.

Anonymous lambdas found in fns become foobar#1, foobar#2 etc.
** DONE abort if too many parameters. abort when too few
** DONE better stackpointer handling
** DONE load args into local vars!!!
** DONE check mem mngmnt for compiler as well
** DONE macroexpand macros before compiling
** DONE test macro
** DONE Fix memory leak for interpreter
** DONE empty fn body should return nil
** DONE Gets tests to pass again interpreter
** DONE check parameter count!!!
** DONE first class functions
** DONE closures
** DONE rest args
** DONE wrap sys fns so they can become lambdas
** DONE add root fns to function table when they get used at all
** DONE implement calling wajure fn from js
* done interpreter
** DONE quasiquote has bug where vector becomes list
`(let [a 1] a)
** DONE put ifdefs in for system libs so we're ready for wasm
#include <stdarg.h>  //va_start, va_list
#include <stdio.h>   //printf, puts
#include <stdlib.h>  //malloc, calloc, realloc
** DONE compile runtime to wasm
and link them to compiled wajure code
runtime includes:
- builtin fns
- memory management

** DONE closures
** DONE returning partials from fn not working
** DONE memory pool
** DONE persistend list with mem pool
** DONE replace mpc
** DONE reference counting

* Good to know
** stack
Before we call a fn we put all args on the stack, then adjust the stackpointer
to point to the first free mem again. After returning we set the sp back again.
When calling fn we know how many args are passed so we can hardcode the sp
adjustment. When in the fn we have to subtract offset from the sp to get at the
args.

Alternatively we could adjust the sp in the fn itself but we'd have to rely on
the wasm arg count arg that any fn gets passed in. We'd add that arg count to
the sp before adding args to the stack frame and then calling a fn. On return
we'd subtract it again. When getting at the lispy params on the stack we'd have
to first add the arg count, then subtract the expected arg count, again relying
on the passed in arg count in second wasm param.

First solution uses hardcoded values, second doesn't.

Stack looks like this btw:

arg2 arg1 arg0 | x x rest_arg arg1 arg0 | etc.

where sp points at the |'s and we extract the args from the stack frame just
before the sp.

This is so that we can easily add partial args on top (as found in a lval_wasm_lambda)
** rename wajure to wajure ??
** To create/update compile_commmands.json:

    make clean
    bear make

    rc -J

https://github.com/Andersbakken/rtags/wiki/Usage
** Emacs compile commands:
*** Build executable and run interpreter on wajure/run.wajure
make clean
make run
*** Build executable and compile wajure/compile.wajure
make clean
make compile
*** Build wasm runtime (compiles wajure interpreter to wasm):
PLATFORM=wasm make clean
PLATFORM=wasm make runtime

*  More from wajure tutorial
** Ch10
 Add a builtin function cons that takes a value and a Q-Expression and appends it to the front.
 Add a builtin function len that returns the number of elements in a Q-Expression.
 Add a builtin function init that returns all of a Q-Expression except the final element.
** Ch13
Create builtin logical operators or ||, and && and not ! and add them to the language.
Define a recursive Lisp function that returns the nth item of that list.
Define a recursive Lisp function that returns 1 if an element is a member of a list, otherwise 0.
Define a Lisp function that returns the last element of a list.
Define in Lisp logical operator functions such as or, and and not.
** Ch14
Adapt the builtin function join to work on strings.
Adapt the builtin function head to work on strings.
Adapt the builtin function tail to work on strings.
Create a builtin function show that can print the contents of strings as it is (unescaped).
Add functions to wrap all of C's file handling functions such as fopen and fgets.
