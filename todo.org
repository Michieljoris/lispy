* TODO compiler
** freeing a lval_wasm_lambda!!!
we need to free its closure and partials!!
** Refactor: return not just Ber, but a struct with info on the compile just done *plus* ber
- so we can more easily see if we just compiled a fn call. iso relying on is_fn_call flag
- we might be able to do optimisations, such as mutually cancelling retain and release calls
** compile test suite
** DONE make sure that every fn added has unique wasm name
So wasmified sys fns are called eg sys_print

And lambdas (such as foobar) found in compile env should be renamed and
numbered, eg: l1_foobar, no I don't think that's needed: we use the latest lval
defined for a symbol in the compiler env.

Anonymous lambdas found in fns become foobar#1, foobar#2 etc.
** DONE abort if too many parameters. abort when too few
** better stackpointer handling
** load args into local vars!!!
** better compile time arg count checking
You could be a bit smarter about it at compile time.
1. When a symbol resolves to a sys fn you can check arg count
2. When a symbol resolves to a root lambda fn (as found in compiler env) you can check arg count
3. When a symbol resolves to lval_compiler in some cases we can know whether the
   lval_compiler is a ref to a lambda, and which one eg:
   (let [f (fn [x] x)] (f 123)) but also in:
    (let [f (fn [x y] ..) g (partial f 1)] (g 2)) but not in:
    (fn [g] (g 123))
** (let [a 1] (def f [] a)), so use in non root form
This shouldn't be too hard. We just need to pass a closure to the f lambda
** add release and retain to wasm code
** check mem mngmnt for compiler as well
** pass floats, strings, maps, vectors, sets etc from js to wajure fn
Currently only ints work
** named fns for recursion of locally defined lambdas
Also, clojure allows it.
** implement maps and sets
** replace list implementations of maps, sets and vectors with permanent data structures other than list
-> vector and map hamt.
** implement: if, do, try, throw, str, loop/recur, quote, quasiquote, doseq, keywords, apply, map, reduce, and, or, xor, doseq, multimethods, destructering, namespaces, meta data
** partial
** apply
https://github.com/clojure/clojure/blob/38bafca9e76cd6625d8dce5fb6d16b87845c8b9d/src/clj/clojure/core.clj#L660
Use core lib fn to reduce args to a single list
Then call wasm implementation of apply* that receives a list and puts them on wajure operand stack and calls fn
** multi arity fns!!!
** max str size, elide with warning or abort
** check for max closure size (currently 128 vars (CHAR512 mempool type))
** find out about and add binaryen optimisations
** add wajure interpreter to the runtime
** add stdlib (defined in wajure and compiled) to runtime
Similar to clojure.core. Probably needs namespaces implemented first
* TODO interpreter
** reader has bug where last parens gets ignored
** add rest of tests from mal
** implement: str, loop/recur, doseq, keywords, apply, map, reduce, and, or, xor, doseq, multimethods, destructering, namespaces, meta data
** partial
** apply
https://github.com/clojure/clojure/blob/38bafca9e76cd6625d8dce5fb6d16b87845c8b9d/src/clj/clojure/core.clj#L660
Use core lib fn to reduce args to a single list
Then call wasm implementation of apply* that receives a list and puts them on wajure operand stack and calls fn
** implement maps and sets
** replace list implementations of maps, sets and vectors with permanent data structures other than list
-> vector and map hamt.
** implement partial, apply,
** named fns for recursion of locally defined lambdas
Also, clojure allows it.
** multi-arity fns
* TODO Both interpreter and compiler:
** error handling and tracking of line number and pos
Don't cut off compiling, try to continue, produce list of errors.
** gensym and #foo in macro
http://clojure-doc.org/articles/language/macros.html
** implement reader macro for #(+ %1 %2)
** Two special variables are available inside defmacro for more advanced usages:

    &form - the actual form (as data) that is being invoked

    &env - a map of local bindings at the point of macro expansion. The env map is from symbols to objects holding compiler information about that binding.


** implement/copy from clojure.core various macros:
*** Branching:
and or when when-not when-let when-first if-not if-let cond condp cond-> cond->>
*** Looping (see also Sequences):
for doseq dotimes while
*** Working with vars (see also Vars and Environment):
ns declare defmethod defmulti defn- defonce
*** Arranging code differently:
.. doto -> ->>
*** Documenting code:
assert comment doc

* done compiler
** DONE macroexpand macros before compiling
** DONE test macro
** DONE Fix memory leak for interpreter
** DONE empty fn body should return nil
** DONE Gets tests to pass again interpreter
** DONE check parameter count!!!
** DONE first class functions
** DONE closures
** DONE rest args
** DONE wrap sys fns so they can become lambdas
** DONE add root fns to function table when they get used at all
** DONE implement calling wajure fn from js
* done interpreter
** DONE quasiquote has bug where vector becomes list
`(let [a 1] a)
** DONE put ifdefs in for system libs so we're ready for wasm
#include <stdarg.h>  //va_start, va_list
#include <stdio.h>   //printf, puts
#include <stdlib.h>  //malloc, calloc, realloc
** DONE compile runtime to wasm
and link them to compiled wajure code
runtime includes:
- builtin fns
- memory management

** DONE closures
** DONE returning partials from fn not working
** DONE memory pool
** DONE persistend list with mem pool
** DONE replace mpc
** DONE reference counting

* Good to know
** rename wajure to wajure ??
** To create/update compile_commmands.json:

    make clean
    bear make

    rc -J

https://github.com/Andersbakken/rtags/wiki/Usage
** Emacs compile commands:
*** Build executable and run interpreter on wajure/run.wajure
make clean
make run
*** Build executable and compile wajure/compile.wajure
make clean
make compile
*** Build wasm runtime (compiles wajure interpreter to wasm):
PLATFORM=wasm make clean
PLATFORM=wasm make runtime

*  More from wajure tutorial
** Ch10
 Add a builtin function cons that takes a value and a Q-Expression and appends it to the front.
 Add a builtin function len that returns the number of elements in a Q-Expression.
 Add a builtin function init that returns all of a Q-Expression except the final element.
** Ch13
Create builtin logical operators or ||, and && and not ! and add them to the language.
Define a recursive Lisp function that returns the nth item of that list.
Define a recursive Lisp function that returns 1 if an element is a member of a list, otherwise 0.
Define a Lisp function that returns the last element of a list.
Define in Lisp logical operator functions such as or, and and not.
** Ch14
Adapt the builtin function join to work on strings.
Adapt the builtin function head to work on strings.
Adapt the builtin function tail to work on strings.
Create a builtin function show that can print the contents of strings as it is (unescaped).
Add functions to wrap all of C's file handling functions such as fopen and fgets.
