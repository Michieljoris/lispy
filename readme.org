#+TITLE: Readme

Used http://www.buildyourownlisp.com as a (re)introduction to c and to get myself an initial implementation.

Removed qexpr and added quoting instead.

Added some more features as discussed in https://github.com/kanaka/mal such as macros, closures and try/catch/throw.

Replaced arrays with persistent lists (chain of cons cells).

Tests are also from mal repo, as implemented.

Memory management with memory pools and ref counting

Memory pool is adapted from
https://www.semanticscholar.org/paper/Fast-Efficient-Fixed-Size-Memory-Pool%3A-No-Loops-and-Kenwright/4321a91d635d023ab25a743c698be219edcdb1a3,
made a bit more efficient per suggestion and refactored to remove some superfluous code.

Resizing idea is from this blog post http://www.pinksquirrellabs.com/blog/2018/01/31/-fixed-memory-pool-design/, but adding extra data blocks instead of
reallocating.

Env is a association list.

WIP: getting the whole thing to compile to webassembly (without Emscripten!) so we have a lispy interpreter in the browser.

* Run
For editline lib do

   sudo apt-get install libedit-dev

For binaryen clone the repo, edit CMakeLists.txt (see note below) and do

    cmake . && make binaryen && make install

Then:

    make (also runs the binary, with repl.lispy as arg)

Alternatively:

    out/lispy lispy/repl.lispy

There's a repl, but compilation is fast enough to make for a faster feedback loop.

* Notes
- libbinaryen.so is included, and so is binaryen-c.h
  However, the shared lib has to be built with the -pthread flag. So that has to be added to the CMakeLists.txt:

  add_compile_flag("-pthread")

  otherwise you get an error that pthread_create symbol can't be found on running the executable lispy.

  make uses an relative rpath but better is to install libbinaryen.so in /usr/lib or /usr/local/lib Manually or run make install in the binaryen repo (after editing the CMakeLists.txt)
* TODO:
- expand lispy stdlib somewhat

  Would be nice:
- persistent vectors and maps, but plists could function as such
- namespaces, keywords, loop/recur, atoms, meta data, multimethods, sets, seq abstraction
- interpreter/compiler in lispy!

Plan is when memory management is under control with memory pools and reference counting to slowly build a compiler to webassembly and/or llvm IR.
* references
** memory pool
- https://www.semanticscholar.org/paper/Fast-Efficient-Fixed-Size-Memory-Pool%3A-No-Loops-and-Kenwright/4321a91d635d023ab25a743c698be219edcdb1a3,
- http://www.pinksquirrellabs.com/blog/2018/01/31/-fixed-memory-pool-design
** reference counting in c
  http://manujbhatia.com/2020/04/11/reference-counting-in-c/
  https://snai.pe/posts/c-smart-pointers
  https://xs-labs.com/en/archives/articles/c-reference-counting/
  https://nullprogram.com/blog/2015/02/17/
  https://codereview.stackexchange.com/questions/146561/reference-counting-in-c99
  https://github.com/mneri/refc/blob/master/src/refc.c
